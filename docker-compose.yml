version: '3.8'

services:
  # 1. Zookeeper (Kafka의 메타데이터 관리자)
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    container_name: zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
    ports:
      - "2181:2181"

  # 2. Kafka (메시지 브로커)
  kafka:
    image: confluentinc/cp-kafka:latest
    container_name: kafka
    depends_on:
      - zookeeper
    ports:
      - "29092:29092"
    environment:
      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'

      KAFKA_BROKER_ID: 1

      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT
      KAFKA_LISTENERS: INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:29092
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka:9092,EXTERNAL://localhost:29092
      KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1

  # 3. Backend (Django API 서버)
  backend:
    container_name: backend
    # ./back-end 폴더의 Dockerfile을 사용하여 이미지를 빌드합니다.
    build:
      context: ./back-end
    ports:
      - "8000:8000" # Django 서버 포트
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      # (개발용) 로컬의 코드를 컨테이너와 동기화하여, 코드 수정 시 자동 재시작
      - ./back-end:/app
    depends_on:
      - kafka # Kafka가 실행된 후에 Django를 실행합니다.

  # 4. Frontend (Nginx + Vue)
  frontend:
    container_name: frontend
    # ./front-end 폴더의 Dockerfile을 사용하여 Nginx 이미지를 빌드합니다.
    build:
      context: ./front-end
    ports:
      # 80번 포트(HTTP 기본)로 접속하면 Nginx가 Vue 앱을 보여줍니다.
      - "80:80"
    depends_on:
      - backend # 백엔드(API)가 실행된 후에 프론트엔드를 실행합니다.

networks:
  default:
    name: de-project-network